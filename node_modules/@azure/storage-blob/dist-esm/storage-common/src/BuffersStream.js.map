{"version":3,"file":"BuffersStream.js","sourceRoot":"","sources":["../../../../storage-common/src/BuffersStream.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC;;AAElC,OAAO,EAAE,QAAQ,EAAmB,MAAM,QAAQ,CAAC;AAOnD;;;;;GAKG;AACH;IAAmC,iCAAQ;IA4BzC;;;;;;;OAOG;IACH,uBACU,OAAiB,EACjB,UAAkB,EAC1B,OAA8B;QAHhC,YAKE,kBAAM,OAAO,CAAC,SAIf;QARS,aAAO,GAAP,OAAO,CAAU;QACjB,gBAAU,GAAV,UAAU,CAAQ;QAI1B,KAAI,CAAC,UAAU,GAAG,CAAC,CAAC;QACpB,KAAI,CAAC,WAAW,GAAG,CAAC,CAAC;QACrB,KAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;;IAC7B,CAAC;IAED;;;;;OAKG;IACI,6BAAK,GAAZ,UAAa,IAAa;QACxB,IAAI,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,UAAU,EAAE;YAC7C,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACjB;QAED,IAAI,CAAC,IAAI,EAAE;YACT,IAAI,GAAG,IAAI,CAAC,qBAAqB,CAAC;SACnC;QAED,IAAM,UAAU,GAAa,EAAE,CAAC;QAChC,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,OAAO,CAAC,GAAG,IAAI,IAAI,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,UAAU,EAAE;YAC3D,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;YAC9E,IAAI,SAAS,GAAG,IAAI,GAAG,CAAC,EAAE;gBACxB,IAAM,GAAG,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,GAAG,CAAC,CAAC;gBACvC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,CAAC;gBAC5E,IAAI,CAAC,iBAAiB,IAAI,IAAI,GAAG,CAAC,CAAC;gBACnC,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC;gBACtB,CAAC,GAAG,IAAI,CAAC;gBACT,MAAM;aACP;iBAAM;gBACL,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;gBACvE,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;gBACpB,IAAI,CAAC,WAAW,EAAE,CAAC;gBACnB,IAAI,CAAC,iBAAiB,IAAI,SAAS,CAAC;gBACpC,CAAC,IAAI,SAAS,CAAC;aAChB;SACF;QAED,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;SACtC;aAAM,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;YAClC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;SAC1B;IACH,CAAC;IACH,oBAAC;AAAD,CAAC,AAxFD,CAAmC,QAAQ,GAwF1C","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Readable, ReadableOptions } from \"stream\";\n\n/**\n * Options to configure the BuffersStream.\n */\nexport interface BuffersStreamOptions extends ReadableOptions {}\n\n/**\n * This class generates a readable stream from the data in an array of buffers.\n *\n * @export\n * @class BuffersStream\n */\nexport class BuffersStream extends Readable {\n  /**\n   * The offset of data to be read in the current buffer.\n   *\n   * @private\n   * @type {number}\n   * @memberof BuffersStream\n   */\n  private byteOffset: number;\n\n  /**\n   * The index of buffer to be read in the array of buffers.\n   *\n   * @private\n   * @type {number}\n   * @memberof BuffersStream\n   */\n  private bufferIndex: number;\n\n  /**\n   * The total length of data already read.\n   *\n   * @private\n   * @type {number}\n   * @memberof BuffersStream\n   */\n  private pushedBytesLength: number;\n\n  /**\n   * Creates an instance of BuffersStream that will emit the data\n   * contained in the array of buffers.\n   *\n   * @param {Buffer[]} buffers Array of buffers containing the data\n   * @param {number} byteLength The total length of data contained in the buffers\n   * @memberof BuffersStream\n   */\n  constructor(\n    private buffers: Buffer[],\n    private byteLength: number,\n    options?: BuffersStreamOptions\n  ) {\n    super(options);\n    this.byteOffset = 0;\n    this.bufferIndex = 0;\n    this.pushedBytesLength = 0;\n  }\n\n  /**\n   * Internal _read() that will be called when the stream wants to pull more data in.\n   *\n   * @param {number} size Optional. The size of data to be read\n   * @memberof BuffersStream\n   */\n  public _read(size?: number) {\n    if (this.pushedBytesLength >= this.byteLength) {\n      this.push(null);\n    }\n\n    if (!size) {\n      size = this.readableHighWaterMark;\n    }\n\n    const outBuffers: Buffer[] = [];\n    let i = 0;\n    while (i < size && this.pushedBytesLength < this.byteLength) {\n      const remaining = this.buffers[this.bufferIndex].byteLength - this.byteOffset;\n      if (remaining > size - i) {\n        const end = this.byteOffset + size - i;\n        outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffset, end));\n        this.pushedBytesLength += size - i;\n        this.byteOffset = end;\n        i = size;\n        break;\n      } else {\n        outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffset));\n        this.byteOffset = 0;\n        this.bufferIndex++;\n        this.pushedBytesLength += remaining;\n        i += remaining;\n      }\n    }\n\n    if (outBuffers.length > 1) {\n      this.push(Buffer.concat(outBuffers));\n    } else if (outBuffers.length === 1) {\n      this.push(outBuffers[0]);\n    }\n  }\n}\n"]}