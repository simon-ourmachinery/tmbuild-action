// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __extends } from "tslib";
import { Readable } from "stream";
/**
 * This class generates a readable stream from the data in an array of buffers.
 *
 * @export
 * @class BuffersStream
 */
var BuffersStream = /** @class */ (function (_super) {
    __extends(BuffersStream, _super);
    /**
     * Creates an instance of BuffersStream that will emit the data
     * contained in the array of buffers.
     *
     * @param {Buffer[]} buffers Array of buffers containing the data
     * @param {number} byteLength The total length of data contained in the buffers
     * @memberof BuffersStream
     */
    function BuffersStream(buffers, byteLength, options) {
        var _this = _super.call(this, options) || this;
        _this.buffers = buffers;
        _this.byteLength = byteLength;
        _this.byteOffset = 0;
        _this.bufferIndex = 0;
        _this.pushedBytesLength = 0;
        return _this;
    }
    /**
     * Internal _read() that will be called when the stream wants to pull more data in.
     *
     * @param {number} size Optional. The size of data to be read
     * @memberof BuffersStream
     */
    BuffersStream.prototype._read = function (size) {
        if (this.pushedBytesLength >= this.byteLength) {
            this.push(null);
        }
        if (!size) {
            size = this.readableHighWaterMark;
        }
        var outBuffers = [];
        var i = 0;
        while (i < size && this.pushedBytesLength < this.byteLength) {
            var remaining = this.buffers[this.bufferIndex].byteLength - this.byteOffset;
            if (remaining > size - i) {
                var end = this.byteOffset + size - i;
                outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffset, end));
                this.pushedBytesLength += size - i;
                this.byteOffset = end;
                i = size;
                break;
            }
            else {
                outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffset));
                this.byteOffset = 0;
                this.bufferIndex++;
                this.pushedBytesLength += remaining;
                i += remaining;
            }
        }
        if (outBuffers.length > 1) {
            this.push(Buffer.concat(outBuffers));
        }
        else if (outBuffers.length === 1) {
            this.push(outBuffers[0]);
        }
    };
    return BuffersStream;
}(Readable));
export { BuffersStream };
//# sourceMappingURL=BuffersStream.js.map